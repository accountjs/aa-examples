import {
  formatEther,
  formatUnits,
  parseEther,
  parseUnits,
} from "ethers/lib/utils.js"
import { Address } from "wagmi"
import { Balance, Currency, TokenSymbol } from "./type"
import { provider } from "./instance"
import { Token__factory } from "@accountjs/contracts"
import { ERC4337EthersProvider } from "@accountjs/sdk"
import { LOCAL_CONFIG } from "@/config"

const { usdt, weth, tokenAddr } = LOCAL_CONFIG

export const formatDecimals = (value: string, decimals = 2): string => {
  // format without rounding
  const [int, dec] = value.split(".")
  const formatted = `${int}.${dec.slice(0, decimals)}`
  return parseFloat(formatted).toFixed(decimals)
}

// trim address as 0x1234...5678
export const trimAddress = (address?: string | Address) => {
  if (!address) return "0x"
  return address.slice(0, 6) + "..." + address.slice(-4)
}

export async function balanceOf(
  of: Address,
  tokenAddress?: Address
): Promise<Balance | undefined> {
  try {
    if (tokenAddress) {
      const token = await Token__factory.connect(tokenAddress, provider)
      const value = await token.balanceOf(of)
      const symbol = (await token.symbol()) as TokenSymbol
      const decimals = await token.decimals()

      return {
        value,
        symbol,
        decimals,
        formatted: formatUnits(value, decimals),
      }
    }

    const value = await provider.getBalance(of)
    return {
      value,
      symbol: 'ETH',
      decimals: 18,
      formatted: formatEther(value),
    }
  } catch (error) {
    console.log("ðŸš€ ~ file: utils.ts:44 ~ error:", error)
  }
}

export const transfer = async (
  target: string,
  amount: string,
  aaProvider: ERC4337EthersProvider,
  currency: Currency
) => {
  const tokenAddress = {
    ETH: null,
    WETH: weth,
    USDT: usdt,
    MYTOK: tokenAddr,
  }[currency]

  if (tokenAddress) {
    const token = await Token__factory.connect(tokenAddress, aaProvider)
    const decimals = await token.decimals()
    const data = Token__factory.createInterface().encodeFunctionData(
      "transfer",
      [target, parseUnits(amount, decimals)]
    )
    const res = await aaProvider.getSigner().sendTransaction({
      data,
      to: tokenAddress,
      gasLimit: 1e6,
    })
    return res.wait()
  }

  return aaProvider
    .getSigner()
    .sendTransaction({
      to: target,
      value: parseEther(amount),
      gasLimit: 1e6,
    })
    .then((tx) => tx.wait())
}

export const parseExpectedGas = (e: Error): Error => {
  // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
  const match = e.message?.match(/paid (\d+) expected (\d+)/)
  if (match != null) {
    const paid = Math.floor(parseInt(match[1]) / 1e9)
    const expected = Math.floor(parseInt(match[2]) / 1e9)
    return new Error(
      `Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(
        (paid / expected) * 100
      )}%, missing ${expected - paid} `
    )
  }
  return e
}

export type RecursiveError = Error & {
  error: RecursiveError
  reason?: string
}

export const getErrorReason = (e: RecursiveError): string => {
  let error = e, reason = e.reason ?? 'Unknown Error'

  while (error.error) {
    error = error.error
    reason = error.reason ?? reason
  }
  return reason
}